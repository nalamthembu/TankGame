#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;
using System.Linq;
using System.Collections.Generic;

public class PhysicsSimulation : MonoBehaviour
{
    [Header("----------General----------")]
    [SerializeField] int maxIterations = 1000;

    [Header("----------Forces----------")]
    [SerializeField] Vector2 forceMinMax;
    [Tooltip("The angle around the Y Axis")]
    [SerializeField] float forceAngleInDegrees;
    [SerializeField] bool randomiseForceAngle;

    SimulatedBody[] simulatedBodies;

    List<Rigidbody> generatedRigidbodies;
    List<Collider> generatedColliders;

    private void OnValidate()
    {
        if (forceMinMax.magnitude <= 0)
        {
            forceMinMax = new(1, 1);
        }
    }

    [ContextMenu("Run Simulation")]
    [System.Obsolete]
    public void RunSimulation()
    {
        AutoGenerateComponents();

        simulatedBodies = FindObjectsOfType<Rigidbody>().Select(rb => new SimulatedBody(rb,rb.transform.IsChildOf(transform))).ToArray();

        Physics.autoSimulation = false;

        foreach(SimulatedBody body in simulatedBodies)
        {
            if (body.isChild)
            {
                float randomForceAmount = Random.Range(forceMinMax.x, forceMinMax.y);
                float forceAngle = (randomiseForceAngle ? Random.Range(0, 360) : forceAngleInDegrees) * Mathf.Rad2Deg;
                Vector3 forceDir = new(Mathf.Sin(forceAngleInDegrees * Mathf.Deg2Rad), 0, Mathf.Cos(forceAngle));
                body.rigidbody.AddForce(forceDir * randomForceAmount, ForceMode.Impulse);
            }
        }

        for (int i = 0; i < maxIterations; i++)
        {
            Physics.Simulate(Time.fixedDeltaTime);

            if (simulatedBodies.All(body => body.rigidbody.IsSleeping() || !body.isChild))
            {
                print("Total Iterations : " + i);

                break;
            }
        }

        Physics.autoSimulation = true;

        foreach(SimulatedBody body in simulatedBodies)
        {
            if (!body.isChild)
                body.Reset();
        }

        RemoveAutoGeneratedComponents();
    }

    void AutoGenerateComponents()
    {
        generatedColliders = new();
        generatedRigidbodies = new();

        foreach (Transform child in transform)
        {
            if (!child.GetComponent<Rigidbody>())
                generatedRigidbodies.Add(child.gameObject.AddComponent<Rigidbody>());

            if (!child.GetComponent<Collider>())
            {
                MeshCollider collider = child.gameObject.AddComponent<MeshCollider>();
                collider.convex = true;
                generatedColliders.Add(collider);
            }
        }
    }

    void RemoveAutoGeneratedComponents()
    {
        foreach (Rigidbody rb in generatedRigidbodies)
            DestroyImmediate(rb);

        foreach (Collider col in generatedColliders)
            DestroyImmediate(col);
    }

    [ContextMenu("Reset")]
    public void ResetAllBodies()
    {
        if (simulatedBodies != null)
        {
            foreach(SimulatedBody body in simulatedBodies)
            {
                body.Reset();
            }
        }
    }

    struct SimulatedBody
    {
        public readonly Rigidbody rigidbody;
        public readonly bool isChild;
        readonly Vector3 originalPosition;
        readonly Quaternion originalRotation;
        readonly Transform transform;

        public SimulatedBody(Rigidbody rigidbody, bool isChild)
        {
            this.rigidbody = rigidbody;
            transform = rigidbody.transform;
            originalPosition = transform.position;
            originalRotation = transform.rotation;
            this.isChild = isChild;
        }

        public void Reset()
        {
            if (rigidbody != null)
            {
                rigidbody.velocity *= 0;
                rigidbody.angularVelocity *= 0;
            }

            transform.position = originalPosition;
            transform.rotation = originalRotation;
        }
    }
}
#endif